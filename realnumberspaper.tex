\documentclass[11pt,a4paper]{article}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{graphicx}
\usepackage[colorlinks=true, breaklinks=true]{hyperref}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{harvard}
\usepackage{agda}
 % The following packages are needed because unicode
 % is translated (using the next set of packages) to
 % latex commands. You may need more packages if you
 % use more unicode characters:

 \usepackage{amssymb}
 \usepackage{bbm}
 \usepackage[english]{babel} 

 % This handles the translation of unicode to latex:

 \usepackage{ucs}
 \usepackage[utf8x]{inputenc}
 \usepackage{autofe}
 \usepackage{verbatim}
 \usepackage{amssymb}
% Some characters that are not automatically defined
% (you figure out by the latex compilation errors you get),
% and you need to define:

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{955}{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{931}{\ensuremath{\Sigma}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}

% Add more as you need them (shouldn’t happen often).

% Using “\newenvironment” to redefine verbatim to
% be called “code” doesn’t always work properly. 
% You can more reliably use:

\usepackage{fancyvrb}

\DefineVerbatimEnvironment
  {code}{Verbatim}
  {} % Add fancy options here if you like.


\title{Formalizing Real Numbers in Agda}
\author{Martin Lundfall}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle
\begin{abstract}
The constructive notion of real numbers was formalized by Errett Bishop in his 1967 book \textit{Foundations of Constructive Analysis} \cite{bishop:85}, in which he showed that most major theorems of real analysis could be proven with constructive methods. This work is a first step towards formalizing this notion in the dependently typed functional programming language and proof assistant Agda. Using the Agda Standard Library and additional work by the GitHub user sabry \cite{sabry}, a major step towards formalizing the definition of real numbers and the equivalence relation is taken. In the process we present an alternate definition of rational numbers in Agda and prove some important statements about functions on rationals.
\end{abstract}
\begin{comment}
n\begin{abstract}
The decentralized infrastructure of the block chain technology Ethereum opens a new set of possibilities for sharing content in a programmable environment. In particular, it is highly suitable for creating a standard library of formalized mathematics to which everyone can add contributions. The database can in theory be automatically checked for validity and to avoid unnecessary repetitions, scanned for relevant results, or even serve as an interactive foundation of a formalized structure of knowledge. The trust-less nature of Ethereum allows communities to make democratic decisions on what contributions should be included in the database, or place bounties on particularly sought functions or proofs.
\end{abstract}
\end{comment}
\clearpage
\tableofcontents{}
\clearpage
\section{Introduction}\label{sec: Introduction}
\subsection{Formal and informal mathematics}\label{subsec: formal & informal}
The term ``Formalized mathematics'' might strike readers unfamiliar with the topic as a pleonasm. What could possibly be more formal than the rigor in which mathematical proofs are presented? But as we will see, a formal approach to mathematics looks fundamentally different from traditional mathematical reasoning. The formalized approach to mathematics strives to lay out the complete path from axioms and definitions to proofs and results, without any step along the way being subject to interpretation. To illustrate what is meant by this, consider a simple informal proof showing that the sum of two odd numbers is equal.

\newtheorem{odd and even}{Definition}
\begin{odd and even}
Even and odd numbers.\\
A natural number n is \textbf{odd} if it can be written as n = 2k+1, for some natural number k.\\
A natural number n is \textbf{even} if it can be written as n = 2y, for some natural number y.\\
\end{odd and even}
\newtheorem{informal}{Theorem}
\begin{informal}
The sum of two odd numbers is equal.\\
Consider the odd numbers m = 2k + 1 and n = 2j + 1. Their sum can be rewritten as:\\
(2k + 1) + (2j + 1) = 2k + 2j + 2 = 2(k + j + 1)\\
Since k, j and 1 are all natural numbers, the right hand side of this equation is on the form $2y$ and therefore even. $\square$
\end{informal}

The proof is trivial and the result comes as no surprise. However, since it does not explicitly state how the conclusion is derived from the axioms, it is essentially informal. To be satisfied with a proof like this it we are required to accept the implicit assumptions on which the reasoning is based.\\
For example, in the step $2n_1+2n_2+2 = 2(n_1+n_2+1)$, we use the definition of addition of multiplication and the distributive property of multiplication over addition, although this is not stated. To accept that the left hand side of the equation indeed equals the right hand side we must recognize the transitivity of the equality relation. We are assumed to know how integers are defined, and accept that $n_1+n_2+1$ is an integer without proof. It is also worth noticing that the because the offered proof does not state that all integers are either odd or equal, we can not on this proof alone rule out the possibility that the resulting sum is not both odd and even. Even the fact that our proof is written in plain English could be a source of ambiguity.\\

Of course, the fact that this proof contains some implicit reasoning does not jeopardize its validity. The omitted steps are all trivially proven, and the proof is easy to follow. If mathematics were always to be conducted with absolute rigor and formality, it would be a very tedious process.\\

Formalized mathematics is mathematical reasoning following a set of strict rules of syntax. It requires all the steps from axioms to conclusion to be presented, and is therefore very amenable for algorithmic proof checking which can be done by a computer. Much of the work in formalized mathematics is therefore done in programming languages specifically designed for this purpose.\\

\subsection{Classical and constructive mathematics}
When formalizing mathematics, one has to make a decision on what logical framework to use. This is a disputed topic within mathematics, with many different answers to the question of what the ``proper'' foundation of mathematical reasoning should be. Two major and opposing approaches are classical and constructive mathematics. One of the biggest disagreements between these two sides lies in in the logical axiom known as the law of the excluded middle. It states that every proposition either has to be true or false. While this is accepted in classical mathematics, constructivists claim that this is not necessarily the case for all propositions.\\
A common example is the famous unproved mathematical statement known as Goldbach's conjecture, which states that every number can be written as the sum of odd primes. According to constructivists, since we have not explicitly constructed a proof or disproof of Goldbach's conjecture, we are not justified in asserting ``Goldbach's Conjecture is either true or false'', a statement that is regarded as true in classical mathematics. \\
Constructivists and classical mathematicians disagree on the interpretation of ``there exists'' in a mathematical sense. This becomes very apparent when working with real numbers, since they are usually, informally, constructed as a converging cauchy sequence of rational numbers. In the classical approach to mathematics, convergence of a sequence is defined as:
\newtheorem{conv}{Definition}
\begin{conv}Convergence of a sequence\\
A sequence $x$ of rational numbers $x_1, x_2, x_3, \dots$ is \textbf{convergent} if for every rational $\epsilon > 0$, there exists an integer $N$ such that for all natural numbers $m, n > N$ we have $| x_m - x_n | < \epsilon$.
\end{conv}
Constructivists are not satisfied with this definition, because it does not entail instructions of \textit{how} the integer N is to be chosen. Claiming that something exists must for a constructivist also be followed by an explicit construction of the object.

\subsection{Formal mathematics in Agda}\label{subsec: Agda}
In this work, I formalize the constructive notion of real numbers as described by Errett Bishop in Grundlehren Der Mathematischen Wissenschaften \cite{bishop:85} in the dependently-typed programming language of Agda. Agda is a functional programming language with a syntax similar to Haskell that essentially deals with two fundamental elements of mathematics, sets and functions. For example, here is the definition of a natural number and addition with natural numbers, $\mathbb{N}$ in Agda:\\

\begin{code}
data ℕ : Set where
  zero : ℕ
  suc  : (n : ℕ) → ℕ

_+_ : ℕ → ℕ → ℕ
zero  + n = n
suc m + n = suc (m + n)
\end{code}

We see that the natural numbers is essentially a set which is created by two constructors, \texttt{zero and suc}. \texttt{suc} is short for the successor function, which given any natural number \texttt{n}, constructs the number \texttt{suc n}. \\
The number 3 for example, is written as \texttt{suc (suc (suc (zero)))} in this way. When defining other functions on natural numbers, what we need to do is first state the type of the function (addition takes two natural numbers and outputs a natural number as an answer) and then simply match the definition of $\mathbb{N}$ and explicitly state how the output is constructed.\\
The construction of the subsets of even and odd numbers are constructed in the same way as the informal approach, a natural number n is even if there exists ($\Sigma$ in agda) natural number k such that $k + k = n$.
\begin{code}
even : ℕ -> Set
even n = Σ ℕ (λ k -> (k + k) ≡ n)
 
odd : ℕ -> Set
odd n = Σ ℕ (λ k -> suc (k + k) ≡ n)
\end{code}
Before we construct the proof that the sum of two odd numbers are equal we need a couple of more lemmas. The following functions \texttt{+-assoc} and \texttt{+-comm} are proofs that addition is a commutative and associative function. \\
\begin{code}
+-assoc : ∀ m n o → (m + n) + o ≡ m + (n + o)
+-assoc zero    _ _ = refl
+-assoc (suc m) n o = cong suc $ +-assoc m n o

+-comm : ∀ m n → m + n ≡ n + m
+-comm zero    n = sym $ +-right-identity n
+-comm (suc m) n =
  begin
    suc m + n
  ≡⟨ refl ⟩
    suc (m + n)
  ≡⟨ cong suc (+-comm m n) ⟩
    suc (n + m)
  ≡⟨ sym (+-suc n m) ⟩
    n + suc m
  ∎
\end{code}
It is worth notable that there is essentially no difference between writing a function in Agda and writing a proof. In fact, proofs are simply functions which has the statement as type, and if one can define a function that outputs the desired type, then the proof is correct.\\
This connection between computer programs and formal logic was discovered by Haskell Curry and William Alvin Howard in the middle of the 20th century and is known as the Curry-Howard correspondence.\\
We are now ready to prove the previously given theorem stating that the sum of two odd numbers are equal. As you can see, the idea of the proof is the same, but for every step in our reasoning we need to give a proof of how the next step follows from the previous.\\
When comparing the following proof with the previous, informal one, we might gain an understanding of how much is taken for granted in the common, informal approach to mathematics. 
\begin{code}
o+o : {m n : ℕ} → odd n → odd m → even (n + m)
o+o {m} {n} (j , p) (k , q) = suc (j + k) , 
  (begin 
    suc (j + k + suc (j + k)) 
≡⟨ cong suc (ℕ+-comm (j + k) (suc (j + k)))  ⟩ 
    suc (suc (j + k + (j + k))) 
≡⟨ cong (λ a -> suc (suc a)) (ℕ+-assoc j k (j + k))  ⟩ 
    suc (suc (j + (k + (j + k)))) 
≡⟨ cong (λ a -> suc (suc (j + a))) (sym (ℕ+-assoc k j k))  ⟩ 
    suc (suc (j + (k + j + k))) 
≡⟨ cong (λ a -> suc (suc (j + (a + k)))) (ℕ+-comm k j)  ⟩
    suc (suc (j + (j + k + k))) 
≡⟨ cong (λ a -> (suc (suc (j + a)))) (ℕ+-assoc j k k)  ⟩ 
    suc (suc (j + (j + (k + k)))) 
≡⟨ cong (λ a -> suc (suc a)) (sym (ℕ+-assoc j j (k + k)))  ⟩ 
    suc (suc (j + j + (k + k))) 
≡⟨ cong suc (ℕ+-comm (suc (j + j)) (k + k)) ⟩ 
    suc (k + k) + suc (j + j) ≡⟨ cong₂ _+_  q p  ⟩ 
    m + n ≡⟨ ℕ+-comm m n  ⟩ 
    n + m
  ∎)
\end{code}
For a more thorough guide on Agda, I recommend checking out one of tutorials available on the Agda wiki at \url{http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Othertutorials}.

\section{Constructing real numbers in Agda}\label{sec: reals in agda}
This work is an Agda implementation of the constructive definition of real numbers as given by Errett Bishop in Grundlehren Der Mathematischen Wissenschaften \cite{bishop:85} to work with the current Agda Standard Library (2.4.2). One existing module, \texttt{Data/Rational.agda} has been modified and two new modules, \texttt{Data/Rational/Properties.agda} and \texttt{Data/Real.agda} has been added.\\
The modules are listed in their current state as attachments to this document, or can be found at .\\
\subsection{Redefining rational numbers}
The current current Agda Standard Library (2.4.2.2) contains only a small module Data.Rational in which rational numbers are defined, but lacks the necessary functions to define real numbers. Therefore I have used the contributions made by the GitHub user sabry at (\url{https://github.com/sabry/agda-stdlib/blob/master/src/Data/Rational.agda}) as a starting point. \\
I have made a significant change to the definition of a rational number by not requiring the numerator and denominator to be coprime. While working with rationals it became apparent that requiring coprimality made theorem proving highly demanding, both for human effort and computer power. Therefore, instead of:
\begin{code}
record ℚ : Set where
  field
    numerator     : ℤ
    denominator-1 : ℕ
    isCoprime     : True (C.coprime? ∣ numerator ∣ (suc denominator-1))
\end{code}
We will simply write:
\begin{code}
record ℚ : Set where
  constructor _÷suc_
  field
    numerator     : ℤ
    denominator-1 : ℕ
\end{code}
Skipping the requirement of coprimality makes certain statements easier to prove, and defining functions a lot simpler. On the other hand, consider the equivalence relation on rational numbers:
\begin{code}
_≃_ : Rel ℚ Level.zero
p ≃ q = numerator p ℤ.* (+ suc (denominator-1 q)) ≡
        numerator q ℤ.* (+ suc (denominator-1 p))
  where open ℚ
\end{code}
Since we can have several elements in the same equivalence class, this relation is no longer synonomous with the identically equal relation, $\equiv$. This makes us unable to modify expressions with functions like cong and subst, and instead we have to show that the functions we define on rationals preserve the equivalence relation.\\
It is also worth mentioning that we would rarely require rational numbers to be given on their coprime form in informal mathematics. The new definition makes working with rational numbers closer to how one might work with rational numbers using pen and paper. Compare the formal definitions with Bishop's definition of a rational number:\\
\blockquote{
For us, a \textit{rational number} will be an expression of the form \textit{p/q} where $p$ and $q$ are integers with $q\neq0$.
}\\
What still differs between the two definitions is the fact that Bishop allows negative numbers in the denominator, whereas we do not. This minor change does not have any significant impact in working with rational numbers, and is only for convenience. We can more easily convenient to construct rational numbers in Agda by just allowing natural numbers larger than zero as denominators.\\
Several lemmas used in the module \texttt{Data/Real.agda} can be found in the new module \texttt{Data/Rational.agda}
\subsection{Definition and equivalence of real numbers}
The definition of a real number is almost identical to the definition given by Bishop, with one minor modification. Where Bishop describes a sequence as a mapping of the stricly positive integers to rationals, we will define it as a mapping from the natural numbers to rationals. This makes things a bit nicer. Where Bishop writes:
\blockquote{
A sequence of rational numbers is \textit{regular} if 
$$| x_m - x_n | \leq m^{-1} + n^{-1} (m, n \in \mathbb{Z}^*)$$
A \textit{real number} is a regular sequence of rational numbers.
}
we will write the following:
\begin{code}
--A real number is defined as sequence and 
--a proof that the sequence is regular
record ℝ : Set where
  constructor Real
  field
    f : ℕ -> ℚ
    reg : {n m : ℕ} -> ∣ f n ℚ.- f m ∣ ℚ.≤ (suc n)⁻¹ ℚ.+ (suc n)⁻¹

\end{code}
TODO: attachments
\bibliography{citations}
\bibliographystyle{kluwer}
\end{document}

But the line between the two of these elements is blurred by the fact that agda is dependently typed, meaning that a set can take arguments of other sets or functions as input

How these rules of syntax are to be defined , and in the  are many interesting philo sophical questions whic arises from such an endeavor.
