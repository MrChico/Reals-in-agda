\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{graphicx}
\usepackage[colorlinks=true, breaklinks=true]{hyperref}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{harvard}
\usepackage{agda}
 % The following packages are needed because unicode
 % is translated (using the next set of packages) to
 % latex commands. You may need more packages if you
 % use more unicode characters:

 \usepackage{amssymb}
 \usepackage{bbm}
 \usepackage[english]{babel} 

 % This handles the translation of unicode to latex:

 \usepackage{ucs}
 \usepackage[utf8x]{inputenc}
 \usepackage{autofe}
 \usepackage{verbatim}
 \usepackage{amssymb}
% Some characters that are not automatically defined
% (you figure out by the latex compilation errors you get),
% and you need to define:

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{955}{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{931}{\ensuremath{\Sigma}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}

% Add more as you need them (shouldn’t happen often).

% Using “\newenvironment” to redefine verbatim to
% be called “code” doesn’t always work properly. 
% You can more reliably use:

\usepackage{fancyvrb}

\DefineVerbatimEnvironment
  {code}{Verbatim}
  {} % Add fancy options here if you like.


\title{Formalizing Real Numbers in Agda}
\author{Martin Lundfall}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle
\begin{abstract}
The constructive notion of real numbers was formalized by Errett Bishop in his 1967 book \textit{Foundations of Constructive Analysis}, in which he showed that most major theorems of real analysis could be proven with constructive methods. This work is a first step towards formalizing this notion in the dependently typed functional programming language and proof assistant Agda. Using the Agda Standard Library and additional work by the GitHub user sabry, a major step towards formalizing the definition of real numbers and the equivalence relation is taken. In the process we present an alternate definition of rational numbers in Agda and prove some important statements about functions on rationals.
\end{abstract}
\begin{comment}
n\begin{abstract}
The decentralized infrastructure of the block chain technology Ethereum opens a new set of possibilities for sharing content in a programmable environment. In particular, it is highly suitable for creating a standard library of formalized mathematics to which everyone can add contributions. The database can in theory be automatically checked for validity and to avoid unnecessary repetitions, scanned for relevant results, or even serve as an interactive foundation of a formalized structure of knowledge. The trust-less nature of Ethereum allows communities to make democratic decisions on what contributions should be included in the database, or place bounties on particularly sought functions or proofs.
\end{abstract}
\end{comment}
\clearpage
\tableofcontents{}
\clearpage
\section{Introduction}\label{sec: Introduction}
\subsection{Formal and informal mathematics}\label{subsec: formal & informal}
The term ``Formalized mathematics'' might strike readers unfamiliar with the topic as a pleonasm. What could possibly be more formal than the rigor in which mathematical proofs are presented? But as we will see, a formal approach to mathematics looks fundamentally different from traditional mathematical reasoning. The formalized approach to mathematics strives to lay out the complete path from axioms and definitions to proofs and results, without any step along the way being subject to interpretation. To illustrate what is meant by this, consider a simple informal proof showing that the sum of two odd numbers is equal.

\newtheorem{odd and even}{Definition}
\begin{odd and even}
Even and odd numbers.\\
A natural number n is \textbf{odd} if it can be written as n = 2k+1, for some natural number k.\\
A natural number n is \textbf{even} if it can be written as n = 2y, for some natural number y.\\
\end{odd and even}
\newtheorem{informal}{Theorem}
\begin{informal}
The sum of two odd numbers is equal.\\
Consider the odd numbers m = 2k + 1 and n = 2j + 1. Their sum can be rewritten as:\\
(2k + 1) + (2j + 1) = 2k + 2j + 2 = 2(k + j + 1)\\
Since k, j and 1 are all natural numbers, the right hand side of this equation is on the form $2y$ and therefore even. $\square$
\end{informal}

The proof is trivial and the result comes as no surprise. However, since it does not explicitly state how the conclusion is derived from the axioms, it is essentially informal. To be satisfied with a proof like this it we are required to accept the implicit assumptions on which the reasoning is based.\\
For example, in the step $2n_1+2n_2+2 = 2(n_1+n_2+1)$, we use the definition of addition of multiplication and the distributive property of multiplication over addition, although this is not stated. To accept that the left hand side of the equation indeed equals the right hand side we must recognize the transitivity of the equality relation. We are assumed to know how integers are defined, and accept that $n_1+n_2+1$ is an integer without proof. It is also worth noticing that the because the offered proof does not state that all integers are either odd or equal, we can not on this proof alone rule out the possibility that the resulting sum is not both odd and even. Even the fact that our proof is written in plain English could be a source of ambiguity.\\

Of course, the fact that this proof contains some implicit reasoning does not jeopardize its validity. The omitted steps are all trivially proven, and the proof is easy to follow. If mathematics were always to be conducted with absolute rigor and formality, it would be a very tedious process.\\

Formalized mathematics is mathematical reasoning following a set of strict rules of syntax. It requires all the steps from axioms to conclusion to be presented, and is therefore very amenable for algorithmic proof checking which can be done by a computer. Much of the work in formalized mathematics is therefore done in programming languages specifically designed for this purpose.\\

\subsection{Classical and constructive mathematics}
When formalizing mathematics, one has to make a decision on what logical framework to use. This is a disputed topic within mathematics, with many different answers to the question of what the ``proper'' foundation of mathematical reasoning should be. Two major and opposing approaches are classical and constructive mathematics. One of the biggest disagreements behind these viewpoints lies in in the logical axiom known as the law of the excluded middle. It states that every proposition either has to be true or false. While this is accepted in classical mathematics, constructivists claim that this is not necessarily the case for all propositions. An example is the famous unproved mathematical statement known as Goldbach's conjecture, which states that every number can be written as the sum of odd primes. According to constructivists, since we have not explicitly constructed a proof or disproof of Goldbach's conjecture, we are not justified in asserting ``Goldbach's Conjecture is either true or false'', a statement that is regarded as true in classical mathematics. \\
Constructivists and classical mathematicians disagree on the interpretation of ``there exists'' in a mathematical sense. This becomes very apparent in the definition of real numbers. 

\subsection{Formal mathematics in Agda}\label{subsec: Agda}
In this thesis, I will be demonstrating how to formalize the constructive definition of real numbers as described by Errett Bishop in Grundlehren Der Mathematischen Wissenschaften \cite{bishop:67} in the dependently-typed programming language of Agda. Agda is a Haskell based language that essentially deals with two fundamental elements of mathematics, sets and functions. For example, here is the definition of a natural number and addition with natural numbers, $\mathbb{N}$ in Agda:\\

\begin{code}
data ℕ : Set where
  zero : ℕ
  suc  : (n : ℕ) → ℕ

_+_ : ℕ → ℕ → ℕ
zero  + n = n
suc m + n = suc (m + n)
\end{code}

We see that the natural numbers is essentially a set which is created by two constructors, \texttt{zero and suc}. \texttt{suc} is short for the successor function, which given any natural number \texttt{n}, constructs the number \texttt{suc n}. \\
The number 3 for example, is written as \texttt{suc (suc (suc (zero)))} in this way. When defining other functions on natural numbers, what we need to do is first state the type of the function (addition takes two natural numbers and outputs a natural number as an answer) and then simply match the definition of $\mathbb{N}$ and explicitly state how the output is constructed.\\
The construction of the subsets of even and odd numbers are constructed in the same way as the informal approach, a natural number n is even if there exists ($\Sigma$ in agda) natural number k such that $k + k = n$.
\begin{code}
even : ℕ -> Set
even n = Σ ℕ (λ k -> (k + k) ≡ n)
 
odd : ℕ -> Set
odd n = Σ ℕ (λ k -> suc (k + k) ≡ n)
\end{code}
Before we construct the proof that the sum of two odd numbers are equal we need a couple of more lemmas. The following functions \texttt{+-assoc} and \texttt{+-comm} are proofs that addition is a commutative and associative function. \\
\begin{code}
+-assoc : ∀ m n o → (m + n) + o ≡ m + (n + o)
+-assoc zero    _ _ = refl
+-assoc (suc m) n o = cong suc $ +-assoc m n o

+-comm : ∀ m n → m + n ≡ n + m
+-comm zero    n = sym $ +-right-identity n
+-comm (suc m) n =
  begin
    suc m + n
  ≡⟨ refl ⟩
    suc (m + n)
  ≡⟨ cong suc (+-comm m n) ⟩
    suc (n + m)
  ≡⟨ sym (+-suc n m) ⟩
    n + suc m
  ∎
\end{code}
It is worth notable that there is essentially no difference between writing a function in Agda and writing a proof. In fact, proofs are simply functions which has the statement as type, and if one can define a function that outputs the desired type, then the proof is correct.\\
This connection between computer programs and formal logic was discovered by Haskell Curry and William Alvin Howard in the middle of the 20th century and is known as the Curry-Howard correspondence.\\
We are now ready to prove the previously given theorem stating that the sum of two odd numbers are equal. As you can see, the idea of the proof is the same, but for every step in our reasoning we need to give a proof of how the next step follows from the previous.\\
When comparing the following proof with the previous, informal one, we might gain an understanding of how much is taken for granted in the common, informal approach to mathematics. 
\begin{code}
o+o : {m n : ℕ} → odd n → odd m → even (n + m)
o+o {m} {n} (j , p) (k , q) = suc (j + k) , 
  (begin 
    suc (j + k + suc (j + k)) ≡⟨ cong suc (ℕ+-comm (j + k) (suc (j + k)))  ⟩ 
    suc (suc (j + k + (j + k))) ≡⟨ cong (λ a -> suc (suc a)) (ℕ+-assoc j k (j + k))  ⟩ 
    suc (suc (j + (k + (j + k)))) ≡⟨ cong (λ a -> suc (suc (j + a))) (sym (ℕ+-assoc k j k))  ⟩ 
    suc (suc (j + (k + j + k))) ≡⟨ cong (λ a -> suc (suc (j + (a + k)))) (ℕ+-comm k j)  ⟩
    suc (suc (j + (j + k + k))) ≡⟨ cong (λ a -> (suc (suc (j + a)))) (ℕ+-assoc j k k)  ⟩ 
    suc (suc (j + (j + (k + k)))) ≡⟨ cong (λ a -> suc (suc a)) (sym (ℕ+-assoc j j (k + k)))  ⟩ 
    suc (suc (j + j + (k + k))) ≡⟨ cong suc (ℕ+-comm (suc (j + j)) (k + k)) ⟩ 
    suc (k + k) + suc (j + j) ≡⟨ cong₂ _+_  q p  ⟩ 
    m + n ≡⟨ ℕ+-comm m n  ⟩ 
    n + m
  ∎)
\end{code}
For a more thorough guide on Agda, I recommend checking out of of tutorials available on the Agda wiki. \cite{agdatutorial}\\

%One might even wonder why anyone would be interested in such a tedious endeavour as formalizing mathematics. One answer might 

\section{Constructing real numbers in Agda}\label{sec: reals in agda}
This work is an Agda implementation of the constructive definition of real numbers as given by Errett Bishop in Grundlehren Der Mathematischen Wissenschaften \cite{bishop:67}. 
\subsection{Redefining rational numbers}
The current current Agda Standard Library (2.4.2.2) contains only a small module Data.Rational in which rational numbers are defined, but lacks the necessary functions to define real numbers. Therefore I have used the contributions made by the GitHub user sabry at (\url{https://github.com/sabry/agda-stdlib/}) as a starting point. However, I have made one significant change to the definition of a rational number, by not requiring them to be coprime. It became apparent while proving theorems about rationals that the current requirement of coprimality (with the accompanying proof) became to tedious to work with. Therefore, instead of:
\begin{code}
record ℚ : Set where
  field
    numerator     : ℤ
    denominator-1 : ℕ
    isCoprime     : True (C.coprime? ∣ numerator ∣ (suc denominator-1))
\end{code}
We will simply write:
\begin{code}
record ℚ : Set where
  constructor _÷suc_
  field
    numerator     : ℤ
    denominator-1 : ℕ
\end{code}
Another advantage of the latter definition is that it is closer to the way rational numbers are commonly defined. Bishop gives the following definition:
\begin{blockquote}
For us, a \textit{rational number} will be an expression of the form \textit{p/q} where $p$ and $q$ are integers with $q\neq0$.
\end{blockquote}
What still differs between our formal definition and Bishop's is the fact that Bishop allows negative numbers in the denominator, whereas we do not. This minor change does not have any significant impact in working with rational numbers, and it is more convenient to construct rational numbers in Agda by just allowing natural numbers larger than zero as denominators.

The downside of not forcing rational numbers to always be given on their coprime form is that the equivalence relation, $≃$,  on rational numbers, given by:
\begin{code}
_≃_ : Rel ℚ Level.zero
p ≃ q = numerator p ℤ.* (+ suc (denominator-1 q)) ≡
        numerator q ℤ.* (+ suc (denominator-1 p))
  where open ℚ
\end{code}
is not equivalent to the ``identically equal to'' relation $\equiv$.

\subsection{Definition and equivalence of real numbers}
I have been following Bishops definitions as closely as possible, with only a couple of small changes. Where Bishop describes a sequence as a mapping of the stricly positive integers to rationals, in Agda it is much more convenient to have a sequence starting from zero. Thus where Bishop writes:
\begin{blockquote}
A sequence of rational numbers is \textit{regular} if 
$$| x_m - x_n | \leq m^{-1} + n^{-1} (m, n \in \mathbb{Z}^*)$$
A \textit{real number} is a regular sequence of rational numbers.
\end{blockquote}

Instead, we will create the sequence as a mapping from the natural numbers. We write as follows:
\begin{code}
--Constructs a real number by a giving a sequence and a proof that the sequence is regular
record ℝ : Set where
  constructor Real
  field
    f : ℕ -> ℚ
    reg : {n m : ℕ} -> (∣ (f n) ℚ.- (f m) ∣) ℚ.≤ ((+ 1) ÷suc n) ℚ.+ ((+ 1) ÷suc m)

\end{code}

\bibliography{citations}
\bibliographystyle{kluwer}
\end{document}

But the line between the two of these elements is blurred by the fact that agda is dependently typed, meaning that a set can take arguments of other sets or functions as input

How these rules of syntax are to be defined , and in the  are many interesting philo sophical questions whic arises from such an endeavor.
